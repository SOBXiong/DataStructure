#include <stdio.h>
#include <stdlib.h>
/**
 * @description: Traveling salesman problem(货郎问题)
 *               
 *               输入: 有穷个城市的集合C = {c1,c2,...,cn},
 *                     距离d(ci,cj) = d(cj,ci)∈Z+,1 ≤ i < j ≤ n
 *               
 *               解: 1,2,...,n的排列k1,k2,...,kn使得:
 *               min{∑[i=1~n-1]d(c[ki],c[ki+1]) + d(c[kn],c[k1])}
 * 
 * @method: 解向量为<1,i1,i2,...,i[n-1]>,
 *          其中i1,i2,...,i[n-1]为{2,3,...,n}的排列.
 * 
 *          搜索空间为排列树,结点<i1,i2,...,ik>表示得到k步路线.
 * 
 *          约束条件: 令B = {i1,i2,...,ik},则i[k+1]∈{2,...,,n} - B
 *          即每个结点只能访问一次.(只能选没有走过的结点)
 * 
 *          界: 当前得到的最短巡回路线长度
 * 
 *          代价函数: 设顶点ci出发的最短边长度为li,
 *          dj为选定巡回路线中第j段的长度(走过长度 + 后续长度下届)
 *              L = ∑[j=1~k]dj + l[ik] + ∑[ij∉B]l[ij]
 *          第一部分∑[j=1~k]dj: 已走过路径长度
 *          剩余部分: 剩余长度下界
 * 
 *          搜索树的叶片个数: O((n-1)!),每片树叶对应1条路径,
 *          每条路径有n个结点.
 *          每个结点代价函数计算时间为O(1),每条路径的计算时间为O(n)
 *          最坏情况下算法的时间复杂度: O(n!)
 * 
 * @link: https://www.bilibili.com/video/av7134874?p=73
 **/
int main(){

    return 0;
}